import pexpect, time, chess, random

ENGINE_PATHS = {"Engine A": "engines/stockfish", "Engine B": "engines/stockfish"}

def start_engine(path: str, name: str="Engine", chess960: bool=False, threads: int=None, hash_size:int=None):
    e = pexpect.spawn(path, encoding="utf-8", timeout=None)
    e.sendline("uci"); e.expect("uciok", timeout=120)
    if chess960:
        try: e.sendline("setoption name UCI_Chess960 value true")
        except: pass
    if threads is not None:
        try: e.sendline(f"setoption name Threads value {int(threads)}")
        except: pass
    if hash_size is not None:
        try: e.sendline(f"setoption name Hash value {int(hash_size)}")
        except: pass
    e.sendline("isready"); e.expect("readyok", timeout=120)
    print(f"{name} iniciado e pronto."); return e

def get_engine_move_data(e, fen: str, wtime:int, btime:int, winc:int, binc:int, name="Engine"):
    e.sendline(f"position fen {fen}"); e.sendline(f"go wtime {wtime} btime {btime} winc {winc} binc {binc}")
    best = None; depth = None; nodes = 0; score_cp = score_mate = None
    t0 = time.monotonic()
    while True:
        try:
            line = e.readline().strip()
            if not line: continue
            if "info" in line:
                p = line.split()
                try:
                    if "depth" in p: depth = int(p[p.index("depth")+1])
                    if "nodes" in p: nodes = int(p[p.index("nodes")+1])
                    if "score" in p:
                        stype = p[p.index("score")+1]; sval = int(p[p.index("score")+2])
                        if stype == "cp": score_cp = sval/100.0; score_mate = None
                        else: score_mate = sval; score_cp = None
                except: pass
            if line.startswith("bestmove"):
                best = line.split()[1]; break
        except Exception as ex:
            print(f"[{name}] ERRO ao ler saída da engine: {ex}"); best = "resign"; break
    elapsed_ms = (time.monotonic()-t0)*1000
    nps = nodes / (elapsed_ms/1000) if nodes and elapsed_ms>0 else 0
    return best, depth, nodes, nps, score_cp, score_mate, elapsed_ms

def _generate_chess960_board():
    try:
        idx = random.randrange(960)
        try:
            return chess.Board.from_chess960_pos(idx)
        except AttributeError:
            try:
                pos = chess.chess960_starting_position(idx)
                return chess.Board(pos)
            except Exception:
                return chess.Board(chess.STARTING_FEN)
    except Exception:
        return chess.Board(chess.STARTING_FEN)

def run_chess_match(n1,p1,n2,p2,config):
    print(f"===== INICIANDO PARTIDA ENTRE {n1.upper()} E {n2.upper()} =====")
    e1 = e2 = None
    if config.get("chess960", False):
        board = _generate_chess960_board()
        print(f"Posição inicial Chess960 (FEN): {board.fen()}")
    else:
        board = chess.Board(config.get("initial_fen", chess.STARTING_FEN))
    moves_played = 0; game_pgn = ""; result="*"
    t1 = t2 = config.get("timelimit_ms",600000)
    try:
        e1 = start_engine(p1, n1, chess960=config.get("chess960", False),
                          threads=config.get("threads"), hash_size=config.get("hash_size"))
        e2 = start_engine(p2, n2, chess960=config.get("chess960", False),
                          threads=config.get("threads"), hash_size=config.get("hash_size"))
        while not board.is_game_over() and moves_played < config.get("num_moves",50):
            white = board.turn==chess.WHITE
            name = n1 if white else n2
            proc = e1 if white else e2
            print(f"\n--- Turno {board.fullmove_number}: {'Brancas' if white else 'Pretas'} ({name}) ---")
            print("Tabuleiro atual:\n", board)
            best, depth, nodes, nps, cp, mate, used_ms = get_engine_move_data(
                proc, board.fen(), t1, t2, config.get("increment_ms",100), config.get("increment_ms",100), name
            )
            if white:
                t1 = t1 - used_ms + config.get("increment_ms",100)
            else:
                t2 = t2 - used_ms + config.get("increment_ms",100)
            if not best or best=="resign":
                print(f"[{name}] desistiu ou não encontrou jogada.")
                result = "0-1" if white else "1-0"; break
            try:
                mv = chess.Move.from_uci(best)
                if mv not in board.legal_moves: raise ValueError(f"Jogada ilegal retornada: {best}")
                san = board.san(mv); board.push(mv)
            except Exception as ex:
                print(f"[{name}] ERRO: {ex}. Partida encerrada.")
                result = "0-1" if white else "1-0"; break
            score_str = f"({cp:.2f} CP)" if cp is not None else (f"(Mate em {mate})" if mate is not None else "")
            depth_str = f", Profundidade: {depth}" if depth is not None else ""
            nps_str = f", NPS: {nps:,.0f}" if nps is not None else ""
            print(f"[{name}] jogou: {san} ({best}) {score_str}{depth_str}{nps_str}")
            print(f"Tempo Restante: Brancas {t1/1000:.1f}s, Pretas {t2/1000:.1f}s")
            game_pgn += (f"{board.fullmove_number}. {san} " if white else f"{san} ")
            moves_played += 1
        if board.is_game_over() and result=="*": result = board.result()
        print(f"\n===== PARTIDA ENCERRADA! =====\nResultado final: {result}\nPGN da partida:\n\n{game_pgn.strip()}\n")
    except Exception as ex:
        print(f"\nERRO FATAL INESPERADO: {ex}"); import traceback; traceback.print_exc()
    finally:
        print("\n--- Finalizando engines ---")
        for proc,name in ((e1,n1),(e2,n2)):
            if proc and proc.isalive():
                try: proc.sendline("quit"); proc.close(); print(f"{name} encerrado.")
                except: pass

if __name__=="__main__":
    match_config = {'chess960': True, 'hash_size':2000,'threads':2,'timelimit_ms':15000,'increment_ms':0,'num_moves':1000,
                    'initial_fen': chess.STARTING_FEN}
    run_chess_match("Stockfish", ENGINE_PATHS["Engine A"], "Stockfish", ENGINE_PATHS["Engine B"], match_config)
    
